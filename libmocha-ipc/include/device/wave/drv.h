/**
 * This file is part of libmocha-ipc.
 *
 * Copyright (C) 2012 Dominik Marszk <dmarszk@gmail.com>
 *
 *
 * libmocha-ipc is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * libmocha-ipc is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with libmocha-ipc.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
 
#ifndef __DEVICE_WAVE_DRV_PACKET_H__
#define __DEVICE_WAVE_DRV_PACKET_H__

//suffix AP/BP shows sender of the packet
enum DrvPacketType {
	READ_NV_BACKUP 		= 0x1, // ReadNvBackup 			0x4 long len
	WRITE_NV_BACKUP 	= 0x2, // WriteNvBackup 		dynamic, first 4 byte is long len, followed by buffer to write
	NV_BACKUP_DATA 		= 0x3, //0x3 NvBackupRead		dynamic, contains N bytes from 0x1E700000, requested by DrvPacket with type 0x1, followed by length
	MODEM_RESET 		= 0x4, //0x4 ModemReset?		0x4 (always NULL)
	UNKNOWN1 			= 0xA, //0xA Unknown			echo the packet we got, requested by DrvPacket with type 0xA
	NV_BACKUP_WRITTEN 	= 0xB, //0xB NvBackupWritten	0x4 (always NULL), sent in case of success overwriting of 0x1E700000, buffer to write is probably sent from CP in DrvPacket with header 	= 0x2
	BATT_GAUGE_LEVEL_CHANGE_IND = 0x14, //0x4, uint32_t batt_level - for nearly full batt its 0x50
	PMIC_RTC_WRITE_REQ	= 0x15,	//						0x1, single byte to write
	PMIC_RTC_READ_REQ	= 0x16,	//						0x0?
	PMIC_RTC_WRITE_RESP	= 0x17, //0x17 PmicThing		0x4, return code of writing register
	PMIC_RTC_READ_RESP	= 0x18, //0x18 PmicThing		0xC, {uint32_t value_read_from_register, uint32_t unk1, uint32_t unk2}
	SYSTEM_INFO_REQ		= 0x19, //						0x0? cause sending TA_CHANGE packet if there's USB connected, 4 SOUND_CONFIG packets and HIDDEN_SW_VER packet
	TA_CHANGE_CP		= 0x1A, //						0x2 {uint16_t type} typeEnum {0x8, 0x9, 0xA, 0xC, 0xD, 0xE} cause AP to control charging
	TA_CHANGE_AP		= 0x1A, //0x1A TA_Change		0x4 (1=insert, 2=remove, 0xB=unknown), not sure->{sent only if some condition is met, this condition is set to true by TA_Remove_NotifyCP}
	SOUND_CONFIG 		= 0x1D, //0x1D SoundConfig	0x19C (412), send 4 in row, in response to SYSTEM_INFO_REQ
	DIAG_TRACE 			= 0x28, //0x28 DiagTrace?		dynamic, probably used only in debugging or in case of some serious failure
	UNKNOWN2 			= 0x29, //41 Unknown, possibly dummy, AP should response with exactly the same IPC packet (same type and buffer)
	SET_LCD_STATE 		= 0x2D, //45 SetLcdState	0x1, bool on (1 = wakeup, 0 = goto sleep)
	VIB_STOP 			= 0x2E, //46 VibStop		0x1, unknown
	BT_TM_REQ 			= 0x2F, //47 BtTM
	BT_TM_RESP 			= 0x30, //48 BtTMRsp
	CAM_TM_CP			= 0x33, //51 CamTM
	CAM_TM_AP			= 0x34, //0x34 //CamTestMode	0x4, contains int passed to DevFTMCamDeviceTestResponse or 1, if called from OemTestMode
	HEADSET_KEY 		= 0x36, //0x36 //HeadsetKey		0x4 (1		=press, 0		=release), only for keycode		=0x8A, which is headset button
	LBS_AT_CMD_REQ_CP	= 0x37, //55 LbsATCmdReq
	LBS_AT_CMD_REQ_AP	= 0x38, //0x38 //LbsATCmdReq	dynamic, no damn idea for now, invoked in OemLbsATCmdRequest
	WLAN_INFO_REQ 		= 0x39, //57 ReqWlanInfo
	WLAN_INFO_RSP		= 0x3A, //0x3A //WlanINFO		0x9, byte 0x89, byte WlanTmPowerOn, byte WlanTmPowerOff, byte WLAN_MAC[6], requested by DrvPacket with header = 57, this packet can contain MAC or smth probably
	ATC_WLAN_TEST 		= 0x3B, //59 ATCWlanTest
	WLAN_TM 			= 0x3C, //0x3C //WlanTest		0x8, byte 0x86 and some shit
	WLAN_MFG_CMD 		= 0x3D, //61 WlanMFGCmd
	WLAN_MFG_RESP 		= 0x3E, //0x3E //WlanMFGResp	0xB|0x14, response to WlanMFGCommand
	NV_WRITE_ITEM 		= 0x3F, //0x3F //NvWriteItem	0x7C(124), <writeinfo buffer>, sent to inform/confirm(if it was modem's request) modem NV item write into flash, buffer[0]=short(0x2758) means INT, after that comes buffer[4]		=short(newValue) OR buffer[0]		=short(0x2757) means STRING, buffer[4] 		= string(20)(newValue) (20 is max len of modem nv string shared with apps)
	HIDDEN_SW_VER 		= 0x44, //0x44 //HiddenSWVer	0x14 (20), send after AppsSettings
	COMPASS_DATA 		= 0x4B, //0x4B //CompassData	0x9, probably reading of compass, requested by DrvPacket with header 		= 74 followed by 1 byte (equal to 1 or 2 or else (3 or 0 maybe, doesn't matter))
	DRV_STAT 			= 0x4C, //0x4C //DrvStat??		0xCC (204)
	LBS_UNK1 			= 0x49, //0x49 //LbsThing		0x6, contains databuffer generated by sub 4012DE64 GenerateLbsDataMaybe, requested by DrvPacket with header = 72, first byte != 1 and first byte != 0
	BOOT_INFO			= 0x4E, //0x4E //BootInfo		0x1, contains byte from (SharedBootInfo+0x3C), no idea what's that, requested by DrvPacket with header = 77
	PS_START_REQ		= 0x4F, // requested by CP	
	PS_START_RESP		= 0x50, //0x50 // 				0x1, result of proximity_sensor_detect_start, requested by DrvPacket with header = 79
	PS_STOP_REQ			= 0x51, // requested by CP
	PS_STOP_RESP		= 0x52, //0x52 // 				0x1, result of proximity_sensor_detect_stop, requested by DrvPacket with header = 81
	PS_IS_CLOSE_REQ		= 0x53, // requested by CP
	PS_IS_CLOSE_RESP	= 0x54, //0x54 //PS_IS_CLOSE	0x1, result of proximity_sensor_is_close, requested by DrvPacket with header = 83
	BATT_GAUGE_STATUS_REQ	= 0x55, //0x55  0x4 (always NULL) sent during wakeup, requesting level of battery
	BATT_GAUGE_STATUS_RESP	= 0x55, //85 BatteryState, in percent maybe
	TSP_UNK1_REQ		= 0x56,
	TSP_UNK1_RESP		= 0x57, //TSP_related??	0x2, , requested by DrvPacket with header 		= 86 followed by probably 3 bytes
	TA_INFO_REQ			= 0x58, /* Request made by CP to get USB cable status, doesn't have any buffer */
	TA_INFO_RESP		= 0x58, /* Response containing uint8_t with USB connector status (normal value seems to be 0 <n/c> or 5 <connected>) */
	OTHERS				= 0x5A, // OTHERS O.o		0x7, string "Others", requested by DrvPacket with header 		= 89, My damn favourite one!
	FOTA_UPDATE			= 0x5C, // FOTA_Update	0x3|0x7, string "OK"|"FD"|"FC", or "FMA"|"FMB"|"FMC"|"FTA", requested by DrvPacket with header = 91
	FOTA_UNK1			= 0x5D, //sent by CP
	FOTA_UNK2			= 0x5E, //FOTA_related	0x0, requested by DrvPacket with header 		= 93 (0x5D)
	WLAN_MAC			= 0x5F, //95 WlanMAC		0x6, byte[6] WLAN MAC address from NV
	BATT_GAUGE_STATUS_CHANGE_IND		= 0x62, //98 0x1, u8 = battery_percent BattGaugeChangeInd, writing data from packet into batt driver struct and signaling DrvTask
};

#endif